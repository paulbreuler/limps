#!/usr/bin/env node
/**
 * Auto-generates skills.yaml from .claude/skills/ directory
 * Run this script to keep skills.yaml in sync with your skills
 * 
 * Usage: node scripts/generate-skills-manifest.js
 */

const fs = require('fs');
const path = require('path');

const SKILLS_DIR = path.join(__dirname, '..', '.claude', 'skills');
const OUTPUT_FILE = path.join(__dirname, '..', 'skills.yaml');

function escapeYaml(value) {
  // If value contains special YAML characters, wrap in quotes and escape
  if (/[:#\-\[\]{}\|>&*!%@,]/.test(value) || value.includes('\n') || value.includes('"')) {
    return '"' + value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"';
  }
  return value;
}

function parseSkillFile(skillPath) {
  const content = fs.readFileSync(skillPath, 'utf8');
  const lines = content.split('\n');
  
  // Parse YAML frontmatter
  if (lines[0] !== '---') {
    return null;
  }
  
  const metadata = {};
  let i = 1;
  while (i < lines.length && lines[i] !== '---') {
    const line = lines[i];
    const match = line.match(/^([a-z-]+):\s*(.+)$/);
    if (match) {
      metadata[match[1]] = match[2].trim();
    }
    i++;
  }
  
  // Extract first H1 as fallback description
  const h1Match = content.match(/^#\s+(.+)$/m);
  const fallbackDescription = h1Match ? h1Match[1] : '';
  
  return {
    name: metadata.name || path.basename(path.dirname(skillPath)),
    description: metadata.description || fallbackDescription,
    path: `.claude/skills/${path.basename(path.dirname(skillPath))}`,
    tags: metadata.tags ? metadata.tags.split(',').map(t => t.trim()) : []
  };
}

function generateManifest() {
  const skills = [];
  
  if (!fs.existsSync(SKILLS_DIR)) {
    console.error(`Skills directory not found: ${SKILLS_DIR}`);
    process.exit(1);
  }
  
  const skillDirs = fs.readdirSync(SKILLS_DIR)
    .filter(dir => fs.statSync(path.join(SKILLS_DIR, dir)).isDirectory())
    .sort(); // Sort for deterministic output
  
  for (const dir of skillDirs) {
    const skillFile = path.join(SKILLS_DIR, dir, 'SKILL.md');
    if (fs.existsSync(skillFile)) {
      const skill = parseSkillFile(skillFile);
      if (skill) {
        skills.push(skill);
      }
    }
  }
  
  // Sort skills by name for deterministic output
  skills.sort((a, b) => a.name.localeCompare(b.name));
  
  // Generate YAML content
  let yaml = '# Auto-generated by scripts/generate-skills-manifest.js\n';
  yaml += '# Do not edit manually - run the script to regenerate\n\n';

  if (skills.length === 0) {
    yaml += 'skills: []\n';
  } else {
    yaml += 'skills:\n';
    for (const skill of skills) {
      yaml += `  - name: ${escapeYaml(skill.name)}\n`;
      yaml += `    path: ${escapeYaml(skill.path)}\n`;
      yaml += `    description: ${escapeYaml(skill.description)}\n`;
      if (skill.tags.length > 0) {
        yaml += `    tags:\n`;
        for (const tag of skill.tags) {
          yaml += `      - ${escapeYaml(tag)}\n`;
        }
      }
    }
  }
  
  fs.writeFileSync(OUTPUT_FILE, yaml);
  console.log(`✅ Generated skills.yaml with ${skills.length} skills`);
  
  // Also generate a limps-specific manifest (always regenerate, even if empty)
  const planningSkills = skills.filter(s => 
    s.name.includes('plan') || s.name.includes('limps')
  );
  
  let limpsYaml = '# Limps Planning Skills Package\n' +
    '# Install: npx skills add https://github.com/sudosandwich/limps/tree/main/.claude/skills/limps-plan-operations\n\n';

  if (planningSkills.length === 0) {
    limpsYaml += 'skills: []\n';
  } else {
    limpsYaml += 'skills:\n';
    limpsYaml += planningSkills.map(s =>
      `  - name: ${escapeYaml(s.name)}\n` +
      `    path: ${escapeYaml(s.path)}\n` +
      `    description: ${escapeYaml(s.description)}\n`
    ).join('');
  }

  const limpsOutputFile = path.join(__dirname, '..', 'skills-limps.yaml');
  fs.writeFileSync(limpsOutputFile, limpsYaml);
  console.log(`✅ Generated skills-limps.yaml with ${planningSkills.length} planning skills`);
}

generateManifest();
